# Rocketseat's Ignite - Node.js Course Project API üöÄ
## Car Rental Application üöó
![Node.js](https://img.shields.io/badge/Node.js-6DA55F?style=for-the-badge&logo=Node.js&logoColor=white)
![TypeScript](https://img.shields.io/badge/TypeScript-%23007ACC.svg?style=for-the-badge&logo=TypeScript&logoColor=white)
![ESLint](https://img.shields.io/badge/ESLint-4B3263?style=for-the-badge&logo=ESLint&logoColor=white)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-%23316192.svg?style=for-the-badge&logo=PostgreSQL&logoColor=white)
![JWT](https://img.shields.io/badge/JWT-black?style=for-the-badge&logo=JSON%20Web%20Tokens)
![Docker](https://img.shields.io/badge/Docker-%230db7ed.svg?style=for-the-badge&logo=Docker&logoColor=white)

![Project Status](https://img.shields.io/badge/STATUS-IN%20PROGRESS-red)

# Insights Gained During the Course üë®‚ÄçüöÄüìù
Here's a summary of the knowledge and skills acquired during the Rocketseat Ignite - Node.js course:

- [X] **Introduction to TypeScript:** Mastered the fundamentals of TypeScript, a statically typed superset of JavaScript, enhancing code quality and developer productivity.

- [X] **Clean Architecture in API Development:** Delved into the principles of clean architecture, gaining proficiency in designing scalable and maintainable APIs.

- [X] **SOLID Principles:** Thoroughly grasped the SOLID principles, including the Single Responsibility Principle, Open-Closed Principle, Liskov Substitution Principle, Interface Segregation Principle, and Dependency Inversion Principle, enabling the creation of robust and adaptable software systems.

- [X] **Singleton Pattern:** Learned the Singleton design pattern, a crucial tool for ensuring a single instance of a class within a system.

- [X] **Stream Concept:** Explored the concept of streams, vital for handling data efficiently in various scenarios.

- [X] **File Upload:** Gained expertise in enabling file uploads within applications, a common requirement in web development.

- [X] **Swagger Documentation:** Acquired the ability to create comprehensive API documentation using Swagger, simplifying API consumption for other developers.

- [X] **Dependency Injection:** Mastered the art of dependency injection, a key technique for managing component dependencies and promoting code reusability.

- [X] **TypeORM:** Became proficient in TypeORM, a powerful Object-Relational Mapping (ORM) library for database interactions.

- [X] **Docker:** Explored Docker, a containerization platform, and learned how to containerize applications for consistency and scalability.

- [X] **PostgreSQL Database:** Gained hands-on experience with PostgreSQL, a robust and open-source relational database management system, for data storage and retrieval.

- [X] **Test-Driven Development (TDD):** Embraced the philosophy of TDD, writing tests before implementing code to ensure software correctness and reliability.

This course has equipped me with a diverse range of skills and knowledge, enabling me to build high-quality, maintainable, and scalable applications.

### SOLID Principles üí°
Here's a closer look at the SOLID principles, which serve as the foundation for building well-structured and maintainable software:

- **Single Responsibility Principle (S):** Ensures that a class has only one reason to change, promoting code clarity and minimizing side effects.

- **Open-Closed Principle (O):** Encourages software entities (e.g., classes, modules) to be open for extension but closed for modification, fostering code stability.

- **Liskov Substitution Principle (L):** Guarantees that objects of a derived class can be used in place of objects of the base class without affecting the correctness of the program.

- **Interface Segregation Principle (I):** Advocates segregating interfaces into smaller, specialized ones to prevent clients from being forced to implement unnecessary methods.

- **Dependency Inversion Principle (D):** Promotes high-level modules depending on abstractions, rather than concrete implementations, enhancing code flexibility and maintainability.

These SOLID principles collectively contribute to the development of software that is easy to understand, extend, and maintain, fostering a more efficient and collaborative development process.